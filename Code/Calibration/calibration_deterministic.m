%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Filename: calibration_deterministic.m
% Author: Nicholas von Turkovich
% Date: 2/28/2022
% Note(s): Divides the parameter search space into hypercubes and then
% minimizes the SMM criterion to determine the parameters for each
% hypercube that best match our moments. Strongly recommend 36 cores to
% allow all hypercubes to run in parallel
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Script setup

function [] = calibration_deterministic(flag_entry, flag_presclerosis)

    fprintf("Calibration output generated by master_calibration_deterministic.m\n")
    fprintf("Nicholas von Turkovich\n")
    fprintf("Run on " + date)
    fprintf("\n\n")

    % Flags needed for model calibration and logging; seed for simulation and
    % computing markup moments
    flag_strwrite = 1;
    seed = 7+13+2020;

    % Choice of global search algorithm
    alg = "NLOPT_GN_DIRECT";

    % Type of model to be calibrated
    if flag_entry == 0 && flag_presclerosis == 0
        calib_type = "calibration";
    elseif flag_entry == 0 && flag_presclerosis == 1
        calib_type = "calibration_presclerosis";
    else
        calib_type = "calibration_entry";
    end

    % Where to save the calibration run
    log_path = "Output/Logs/Calibration_Deterministic/" + calib_type;

    %% Externally calibrated values, moment targets, and parameter neighborhoods

    disp("--------------------------------------------------")
    disp("Computing parameter combinations")
    disp("--------")

    % Computed using calibration_targets.R

    hyper_gamma = [0.35]; % AA 2019
    hyper_leap = [0];
    hyper_n = [200];

    if flag_presclerosis
        hyper_tfp = [0.89]; % Fernald FRBSF Annual
        hyper_rdgdp = [2.56]; % FRED data
        hyper_lerneralpha = [1.39]; % Hall 2018 
    else
        hyper_tfp = [0.76]; % Fernald FRBSF Annual
        hyper_rdgdp = [4.43]; % FRED data
        hyper_lerneralpha = [2.43]; % Hall 2018 
    end

    % Not targeted moments and statistics
    hyper_innov_mean_pct90 = [[9.63, 28.76]]; % Kogan et al. moments 
    hyper_rd_leader_share = [45]; % Estimated R&D share of leaders by industry from Olmstead-Rumsey
    hyper_mu_end = [0]; % Mu at tail of distribution

    % Parameters that depend on entry/no entry choice
    if flag_entry == 0
        hyper_withinadj = [90.77]; % FHS (same value used in CGLS)

        % Assign weights for each corresponding moment (first three weights are
        % just placeholders for hyper paramters that don't relate to the target
        % moments)
        weights = [[nan, nan, nan, 2, 2, 1, 0, 1, 1, 1, 1, 0, 2, 0, 0, 0, 0]];

        % Create combinations of hyper_parameters (generates only single set
        % unless one of the consistuent parameter groups has multiple rows)
        hyper_combinations = compute_parameter_combinations(hyper_gamma, hyper_leap, hyper_n, hyper_tfp, ...
            hyper_rdgdp, hyper_lerneralpha, hyper_withinadj, hyper_innov_mean_pct90, ...
            hyper_rd_leader_share, hyper_mu_end, weights);
    else
        hyper_entry = [23.9]; % FHS (same value used in CGLS)
        hyper_emp5 = [13.2]; % CGLS data (average employment in 2000,2014)
        hyper_emp10 = [22.0]; % CGLS data (average employment in 2000,2014)

        % Assign weights for each corresponding moment (first three weights are
        % just placeholders for hyper paramters that don't relate to the target
        % moments)
        weights = [[nan, nan, nan, 2, 2, 1, 0, 1, 1, 1, 1, 0, 2, 0, 0, 0, 0, 1, 1]];

        % Create combinations of hyper_parameters (generates only single set
        % unless one of the consistuent parameter groups has multiple rows)
        hyper_combinations = compute_parameter_combinations(hyper_gamma, hyper_leap, hyper_n, hyper_tfp, ...
            hyper_rdgdp, hyper_lerneralpha, hyper_entry, hyper_innov_mean_pct90, ...
            hyper_rd_leader_share, hyper_mu_end, hyper_emp5, hyper_emp10, weights);
    end


    % Generate targets (note that the order always starts with gamma, tfp,
    % rd_gdp, and then lerner alpha; lerner alpha gives us a variety of moments
    % based on simulation so this position is important
    param_combinations = [];
    weight_combinations = [];

    for i = 1:size(hyper_combinations,1)

        iter = 1;

        hyper_params = hyper_combinations(i,:);

        % The first five entries are gamma, leap, n, average annual TFP, and RD/GDP ratio
        target_row = hyper_params(iter:iter+4);
        iter = iter + 5;

        % Simulate Hall 2018 moments
        rng(seed, 'Threefry')
        draw_lerner = betarnd(hyper_params(iter), 8, 1, 1e6);
        draw_gross_markup = 1./(1 - draw_lerner);
        markup_targets = [(mean(draw_gross_markup)-1)*100,...
            (median(draw_gross_markup)-1)*100,...
            quantile(draw_gross_markup - 1, 0.75)*100,...
            quantile(draw_gross_markup - 1, 0.9)*100,...
            quantile(draw_gross_markup - 1, 0.95)*100,...
            quantile(draw_gross_markup - 1, 0.99)*100,...
            std(draw_gross_markup)*100];

        % Collect markup targets
        target_row = [target_row, markup_targets];
        iter = iter + 1;

        % FHK target
        target_row = [target_row, hyper_params(iter)];
        iter = iter + 1;

        % Innovation output
        target_row = [target_row, hyper_params(iter:iter+1)];
        iter = iter + 2;

        % R&D share
        target_row = [target_row, hyper_params(iter)];
        iter = iter + 1;

        % Mass at end of mu distribution
        target_row = [target_row, hyper_params(iter)];
        iter = iter + 1;

        % Additional entry targets
        if flag_entry  
            target_row = [target_row, hyper_params(iter:iter+1)];
            iter = iter + 2;
        end

        % Collect weights for run
        weight_combinations = [weight_combinations; hyper_params(iter:end)];

        param_combinations = [param_combinations; target_row];

    end

    if sum(size(weight_combinations) ~= size(param_combinations)) > 0
        error("Correct weights specification")
    end

    % Create search neighborhoods for our four parameters
    B_neighborhoods = [[0.1, 0.5];...
        [0.5, 5]];
    eta_neighborhoods = [[0, 0.005];...
        [0.005, 0.01];...
        [0.01, 0.05]];
    lambda_neighborhoods = [[1.0025, 1.02];...
        [1.02, 1.5]];
    phi_neighborhoods = [[0, 0.05];...
        [0.05, 0.5];...
        [0.5, 1]];

    if flag_entry == 0
        neighborhoods = compute_parameter_combinations(B_neighborhoods, eta_neighborhoods, ...
            lambda_neighborhoods, phi_neighborhoods);
    else
        B_e_neighborhoods = [[0.1, 5]];
        phi_e_neighborhoods = [[0, 1]];

        neighborhoods = compute_parameter_combinations(B_neighborhoods, eta_neighborhoods, ...
            lambda_neighborhoods, phi_neighborhoods, B_e_neighborhoods, phi_e_neighborhoods);
    end

    if flag_entry == 0

        % Set up header for excel file
        header = ["loss", "tfp_growth", "rd_gdp", "mean_markup", "median_markup", "pct75_markup", "pct90_markup", "pct95_markup", "pct99_markup", "std_markup", "FHK_WITHIN_adj_sh_5y", "mean_innov", "pct90_innov", "rd_leader_share", "mu_end", ...
               "tfp_growth_w", "rd_gdp_w", "mean_markup_w", "median_markup_w", "pct75_markup_w", "pct90_markup_w", "pct95_markup_w", "pct99_markup_w", "std_markup_w", "FHK_WITHIN_adj_sh_5y_w", "mean_innov_w", "pct90_innov_w", "rd_leader_share_w", "mu_end_w", ...
               "B", "eta", "lambda", "phi", "gamma", "leap", "n"];
    else

        % Set up header for excel file
        header = ["loss", "tfp_growth", "rd_gdp", "mean_markup", "median_markup", "pct75_markup", "pct90_markup", "pct95_markup", "pct99_markup", "std_markup", "FHK_ENTRY_sh_5y", "mean_innov", "pct90_innov", "rd_leader_share", "mu_end", "emp5", "emp10",...
               "tfp_growth_w", "rd_gdp_w", "mean_markup_w", "median_markup_w", "pct75_markup_w", "pct90_markup_w", "pct95_markup_w", "pct99_markup_w", "std_markup_w", "FHK_ENTRY_sh_5y_w", "mean_innov_w", "pct90_innov_w", "rd_leader_share_w", "mu_end_w", "emp5_w", "emp10_w", ...
               "B", "eta", "lambda", "phi", "B_e", "phi_e", "gamma", "leap", "n"];
    end

    %% Launch calibrations

    parfor i = 1:size(neighborhoods,1)

        % Identify the bounds to use
        bounds = neighborhoods(i,:);
        internal_lower = bounds(1:2:length(bounds)-1);
        internal_upper = bounds(2:2:length(bounds));
        inputs = mean([internal_lower; internal_upper],1);

         % Setup NLOPT
        if alg == "NLOPT_GN_DIRECT"
            opt = struct('algorithm', NLOPT_GN_DIRECT,...
                'lower_bounds', internal_lower,...
                'upper_bounds', internal_upper,...
                'verbose', 0,...
                'maxtime', 24*10*60*60);
        elseif alg == "NLOPT_GN_DIRECT_L"
            opt = struct('algorithm', NLOPT_GN_DIRECT_L,...
                'lower_bounds', internal_lower,...
                'upper_bounds', internal_upper,...
                'verbose', 0,...
                'maxtime', 24*10*60*60);
        elseif alg == "NLOPT_GN_DIRECT_L_RAND"
            opt = struct('algorithm', NLOPT_GN_DIRECT_L_RAND,...
                'lower_bounds', internal_lower,...
                'upper_bounds', internal_upper,...
                'verbose', 0,...
                'maxtime', 24*10*60*60);
        elseif alg == "NLOPT_G_MLSL_LDS"
            opt = struct('algorithm', NLOPT_G_MLSL_LDS,...
                'lower_bounds', internal_lower,...
                'upper_bounds', internal_upper,...
                'verbose', 0,...
                'maxtime', 24*10*60*60);
            opt.local_optimizer.algorithm = NLOPT_LN_COBYLA;
        elseif alg == "NLOPT_GN_CRS2_LM"
            opt = struct('algorithm', NLOPT_GN_CRS2_LM,...
                'lower_bounds', internal_lower,...
                'upper_bounds', internal_upper,...
                'verbose', 0,...
                'maxtime', 24*10*60*60);
        elseif alg == "NLOPT_GN_ESCH"
            opt = struct('algorithm', NLOPT_GN_ESCH,...
                'lower_bounds', internal_lower,...
                'upper_bounds', internal_upper,...
                'verbose', 0,...
                'maxtime', 24*10*60*60);   
        else
            error("Invalid NL Opt Algorithm")
        end

        % Path for log file associated with this neighborhood
        strwrite = strcat(log_path, num2str(i), "_", alg, ".csv");

        % Write out log shell prior to launching calibration
        if flag_strwrite
           writematrix([header;...
               [nan, nan(1,length(param_combinations(1,:))-3), nan(1,length(weight_combinations(1,:))-3), internal_lower, nan, nan, nan];....
               [nan, nan(1,length(param_combinations(1,:))-3), nan(1,length(weight_combinations(1,:))-3), internal_upper, nan, nan, nan];...
               [nan, param_combinations(1,4:end), weight_combinations(1,4:end), nan(1,length(inputs)), nan, nan, nan];...
               [nan, nan(1,length(param_combinations(1,:))-3), nan(1,length(weight_combinations(1,:))-3), nan(1,length(inputs)), nan, nan, nan]], strwrite); 
        end

        % Define NLOPT objective function
        opt.min_objective = @(inputs) compute_loss_function_wrapper(inputs, param_combinations(1,4:end), param_combinations(1,1:3), weight_combinations(1,4:end), flag_entry, flag_strwrite, strwrite);

        % Calibration
        find_opt = nlopt_optimize(opt, inputs);

    end
    
end
